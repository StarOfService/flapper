// flapper package allows to serialize complex custom structures to a flat map of strings and deserialize it back.
package flapper

import (
  "fmt"
  "reflect"
  "strconv"
)

const (
  DefaultDelimiter = "."
  DefaultPrefix = ""
)

// Marshal returns a flat map of strings for the provided object.
// It travers the object recursively. Map item key is a complex structure which is built
// from the object keys, sleated by dots (by default). The map item value is 
// a corresponding object field value converted to a string.
func Marshal(object interface{}) (map[string]string, error) {
  f, err := New(DefaultPrefix, DefaultDelimiter)
  if err != nil {
    return nil, err
  }

  m, err := f.Marshal(object)
  if err != nil {
    return nil, err
  }

  return m, nil
}

// Unmarshal restores object from the map generated by Marshal
func Unmarshal(data map[string]string, object interface{}) error {
  f, err := New(DefaultPrefix, DefaultDelimiter)
  if err != nil {
    return err
  }

  err = f.Unmarshal(data, object)
  if err != nil {
    return err
  }

  return nil
}

// Flapper struct is used for extended configuration of Marshal and Unmarshal methods.
// It allows to set custom delimiter and prefix.
// When you need this kind of customizaiton, you must use Marshal and Unmarshal methods 
// of the Flapper item instead of simple Marshal and Unmarshal functions described above.
type Flapper struct {
  Delimiter string
  Prefix string
}

// Returns a new *Flapper
func New(prefix, delimiter string) (*Flapper, error) {
  if len(delimiter) == 0 {
    err := fmt.Errorf("Delimiter can't be empty")
    return nil, err
  }
  return &Flapper{
    Delimiter: delimiter,
    Prefix: prefix,
  }, nil
}

// Behaves in a same way as a Marshal function, but uses
// a custom configuration defined at the Flapper object.
func (self *Flapper) Marshal(object interface{}) (map[string]string, error) {
  resp, err := self.marshStruct(reflect.ValueOf(object), self.Prefix)
  if err != nil {
    return nil, fmt.Errorf("Unable to serialize provided object due to the error: %s", err.Error())
  }
  return resp, nil
}

func (self *Flapper) marshStruct(object reflect.Value, prefix string) (map[string]string, error) {
  resp := make(map[string]string)
  for _, f := range structFields(object) {
    name := f.Name

    prefixedName := name
    if len(prefix) > 0 {
      prefixedName = prefix + self.Delimiter + name
    }

    field := object.FieldByName(name)

    switch field.Kind() {
    case reflect.Bool:
      resp[prefixedName] = strconv.FormatBool(field.Bool())
    case reflect.Float32:
      resp[prefixedName] = strconv.FormatFloat(field.Float(), 'E', -1, 32)
    case reflect.Float64:
      resp[prefixedName] = strconv.FormatFloat(field.Float(), 'E', -1, 64)
    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
      resp[prefixedName] = strconv.FormatInt(field.Int(), 10)
    case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
      resp[prefixedName] = strconv.FormatUint(field.Uint(), 10)
    case reflect.String:
      resp[prefixedName] = field.String()
    case reflect.Struct:
      fm, err := self.marshStruct(field, prefixedName)
      if err != nil {
        return nil, fmt.Errorf("Unable to serialize field '%s' for the provided object due to the error: %s", name, err.Error())
      }
      for k, v := range fm {
        resp[k] = v
      }
    default:
      return nil, fmt.Errorf("Field '%s' has unsuppoerted type: %s", name, field.Kind())
    }

  }
  return resp, nil
}

// Behaves in a same way as a Unmarshal function, but uses
// a custom configuration defined at the Flapper object.
func (self *Flapper) Unmarshal(data map[string]string, object interface{}) error {  
  po := reflect.ValueOf(object).Elem()
  err := self.unmarshStruct(data, po, self.Prefix)
  if err != nil {
    return fmt.Errorf("Unable to deserialize provided object due to the error: %s", err.Error())
  }

  return nil
}

func (self *Flapper) unmarshStruct(data map[string]string, object reflect.Value, prefix string) error {
  for _, f := range structFields(object) {
    name := f.Name

    prefixedName := name
    if len(prefix) > 0 {
      prefixedName = prefix + self.Delimiter + name
    }
    value := data[prefixedName]

    field := object.FieldByName(name)

    switch field.Kind() {
    case reflect.Bool:
      d, err := strconv.ParseBool(value)
      if err != nil {
        return fmt.Errorf("Failed to parse 'bool' value '%s' for field '%s' due to the error: %s", value, name, err.Error())
      }
      field.SetBool(d)
    case reflect.Float32:
      d, err := strconv.ParseFloat(value, 32)
      if err != nil {
        return fmt.Errorf("Failed to parse 'float32' value '%s' for field '%s' due to the error: %s", value, name, err.Error())
      }
      field.SetFloat(d)
    case reflect.Float64:
      d, err := strconv.ParseFloat(value, 64)
      if err != nil {
        return fmt.Errorf("Failed to parse 'float64' value '%s' for field '%s' due to the error: %s", value, name, err.Error())
      }
      field.SetFloat(d)
    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
      d, err := strconv.ParseInt(value, 10, 64)
      if err != nil {
        return fmt.Errorf("Failed to parse 'Int64' value '%s' for field '%s' due to the error: %s", value, name, err.Error())
      }
      field.SetInt(d)
    case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
      d, err := strconv.ParseUint(value, 10, 64)
      if err != nil {
        return fmt.Errorf("Failed to parse 'Uint64' value '%s' for field '%s' due to the error: %s", value, name, err.Error())
      }
      field.SetUint(d)
    case reflect.String:
      field.SetString(value)
    case reflect.Struct:
      err := self.unmarshStruct(data, field, prefixedName)
      if err != nil {
        return fmt.Errorf("Unable to deserialize field '%s' for the provided object due to the error: %s", name, err.Error())
      }
    default:
      return fmt.Errorf("Field '%s' has unsuppoerted type: %s", name, field.Kind())
    }

  }
  return nil
}

func structFields(obj reflect.Value) []reflect.StructField {
  t := obj.Type()

  var f []reflect.StructField
  
  for i := 0; i < t.NumField(); i++ {
    field := t.Field(i)
    // we can't access the value of unexported fields
    if field.PkgPath != "" {
      continue
    }

    // // don't check if it's omitted
    // if tag := field.Tag.Get(s.TagName); tag == "-" {
    //   continue
    // }

    f = append(f, field)
  }

  return f
}